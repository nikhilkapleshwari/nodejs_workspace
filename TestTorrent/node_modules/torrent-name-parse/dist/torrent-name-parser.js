'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _xregexp = require('xregexp');

var _xregexp2 = _interopRequireDefault(_xregexp);

var _quality = require('./infos/quality');

var _quality2 = _interopRequireDefault(_quality);

var _resolution = require('./infos/resolution');

var _resolution2 = _interopRequireDefault(_resolution);

var _language = require('./infos/language');

var _language2 = _interopRequireDefault(_language);

var _regex = require('./infos/regex');

var _regex2 = _interopRequireDefault(_regex);

var _fileExtension = require('./infos/file-extension');

var _fileExtension2 = _interopRequireDefault(_fileExtension);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var debug = (0, _debug2.default)('torrents-name-parser');

var TorrentNameParser = function () {
  function TorrentNameParser() {
    _classCallCheck(this, TorrentNameParser);
  }

  _createClass(TorrentNameParser, [{
    key: 'parse',
    value: function parse(name) {
      debug('Trying to parse torrent name : ' + name + '.');

      name = name.trim();
      var normalizedName = name.replace(/_/g, ' ');

      var infos = {
        resolution: this.parseResolution(normalizedName),
        revision: this.parseRevision(normalizedName),
        language: this.parseLanguage(name),
        year: this.parseYear(name)
      };

      // Continue with this :
      // https://github.com/Sonarr/Sonarr/blob/develop/src/NzbDrone.Core/Parser/Parser.cs
      // https://github.com/clems6ever/torrent-name-parser/blob/master/parts/common.js
      //
      // Try to detect :
      //   - Release group
      //   - Subtitles
      //   - Website? Already implemented, just check if accurate
      infos.quality = this.parseQuality(name, normalizedName, infos.resolution).name;

      var website = this.parseWebsite(name);
      if (website !== null) {
        infos.website = website;
      }

      // TODO: better handling of TV show format
      //       Season xx, Sxx, multiple episodes, etc
      //       See https://github.com/Sonarr/Sonarr/blob/develop/src/NzbDrone.Core/Parser/Parser.cs#L26
      var tvShow = this.parseTvShow(name);
      if (tvShow.season !== null && tvShow.episode !== null) {
        infos.tvshow = tvShow;
      }

      return infos;
    }
  }, {
    key: 'parseWebsite',
    value: function parseWebsite(name) {
      /*jshint curly: false */
      var match = _xregexp2.default.exec(name, _regex2.default.website);

      if (match === null) return null;
      if (match.website) return match.website;
    }
  }, {
    key: 'parseYear',
    value: function parseYear(name) {
      /*jshint curly: false */
      var match = _xregexp2.default.exec(name, _regex2.default.year);

      if (match === null) return null;
      if (match.year) return parseInt(match.year);
    }
  }, {
    key: 'parseTvShow',
    value: function parseTvShow(name) {
      /*jshint curly: false */
      var season = null;
      var episode = null;

      _regex2.default.tvshow.forEach(function (regex) {
        var match = _xregexp2.default.exec(name, regex);

        if (match === null) return null;
        if (match.season) season = parseInt(match.season);
        if (match.episode) episode = parseInt(match.episode);
      });

      return {
        season: season,
        episode: episode
      };
    }
  }, {
    key: 'parseLanguage',
    value: function parseLanguage(name) {
      /*jshint curly: false */
      var lowerName = name.toLowerCase();

      if (lowerName.indexOf('english') !== -1) return _language2.default.English;

      if (lowerName.indexOf('french') !== -1) return _language2.default.French;

      if (lowerName.indexOf('spanish') !== -1) return _language2.default.Spanish;

      if (lowerName.indexOf('danish') !== -1) return _language2.default.Danish;

      if (lowerName.indexOf('dutch') !== -1) return _language2.default.Dutch;

      if (lowerName.indexOf('japanese') !== -1) return _language2.default.Japanese;

      if (lowerName.indexOf('cantonese') !== -1) return _language2.default.Cantonese;

      if (lowerName.indexOf('mandarin') !== -1) return _language2.default.Mandarin;

      if (lowerName.indexOf('korean') !== -1) return _language2.default.Korean;

      if (lowerName.indexOf('russian') !== -1) return _language2.default.Russian;

      if (lowerName.indexOf('polish') !== -1) return _language2.default.Polish;

      if (lowerName.indexOf('vietnamese') !== -1) return _language2.default.Vietnamese;

      if (lowerName.indexOf('swedish') !== -1) return _language2.default.Swedish;

      if (lowerName.indexOf('norwegian') !== -1) return _language2.default.Norwegian;

      if (lowerName.indexOf('nordic') !== -1) return _language2.default.Norwegian;

      if (lowerName.indexOf('finnish') !== -1) return _language2.default.Finnish;

      if (lowerName.indexOf('turkish') !== -1) return _language2.default.Turkish;

      if (lowerName.indexOf('portuguese') !== -1) return _language2.default.Portuguese;

      if (lowerName.indexOf('hungarian') !== -1) return _language2.default.Hungarian;

      var match = _xregexp2.default.exec(name, _regex2.default.language);

      if (match === null) return _language2.default.English;
      if (match.vo) return _language2.default.Original;
      if (match.italian) return _language2.default.Italian;
      if (match.german) return _language2.default.German;
      if (match.flemish) return _language2.default.Flemish;
      if (match.greek) return _language2.default.Greek;
      if (match.french) return _language2.default.French;
      if (match.russian) return _language2.default.Russian;
      if (match.dutch) return _language2.default.Dutch;
      if (match.hungarian) return _language2.default.Hungarian;

      return _language2.default.English;
    }
  }, {
    key: 'parseQuality',
    value: function parseQuality(name, normalizedName, resolution) {
      if (_xregexp2.default.test(normalizedName, _regex2.default.rawHD)) {
        return _quality2.default.RawHD;
      }

      var sourceMatch = _xregexp2.default.exec(normalizedName, _regex2.default.source);
      var codecMatch = _xregexp2.default.exec(normalizedName, _regex2.default.codec);

      debug('Source Regex matches', sourceMatch);
      debug('Codec Regex matches', codecMatch);

      if (sourceMatch !== null) {
        if (sourceMatch.bluray) {
          if (codecMatch !== null && (codecMatch.xvid || codecMatch.divx)) {
            return _quality2.default.DVD;
          }

          switch (resolution) {
            case _resolution2.default._2160p:
              return _quality2.default.Bluray2160p;

            case _resolution2.default._1080p:
              return _quality2.default.Bluray1080p;

            case _resolution2.default._480p:
            case _resolution2.default._576p:
              return _quality2.default.DVD;

            default:
              return _quality2.default.Bluray720p;
          }
        }

        if (sourceMatch.webdl) {
          switch (resolution) {
            case _resolution2.default._2160p:
              return _quality2.default.WEBDL2160p;

            case _resolution2.default._1080p:
              return _quality2.default.WEBDL1080p;

            case _resolution2.default._720p:
              return _quality2.default.WEBDL720p;

            default:
              if (name.indexOf('[WEBDL]') !== -1) {
                return _quality2.default.WEBDL720p;
              }

              return _quality2.default.WEBDL480p;
          }
        }

        if (sourceMatch.hdtv) {
          switch (resolution) {
            case _resolution2.default._2160p:
              return _quality2.default.HDTV2160p;

            case _resolution2.default._1080p:
              return _quality2.default.HDTV1080p;

            case _resolution2.default._720p:
              return _quality2.default.HDTV720p;

            default:
              if (name.indexOf('[HDTV]') !== -1) {
                return _quality2.default.HDTV720p;
              }

              return _quality2.default.SDTV;
          }
        }

        if (sourceMatch.bdrip || sourceMatch.brrip) {
          switch (resolution) {
            case _resolution2.default._720p:
              return _quality2.default.Bluray720p;

            case _resolution2.default._1080p:
              return _quality2.default.Bluray1080p;

            default:
              return _quality2.default.DVD;
          }
        }

        if (sourceMatch.dvd) {
          return _quality2.default.DVD;
        }

        if (sourceMatch.pdtv || sourceMatch.sdtv || sourceMatch.dsr || sourceMatch.tvrip) {
          if (_xregexp2.default.test(normalizedName, _regex2.default.highDefPdtv)) {
            return _quality2.default.HDTV720p;
          }

          return _quality2.default.SDTV;
        }
      }

      switch (resolution) {
        case _resolution2.default._2160p:
          return _quality2.default.HDTV2160p;

        case _resolution2.default._1080p:
          return _quality2.default.HDTV1080p;

        case _resolution2.default._720p:
          return _quality2.default.HDTV720p;

        case _resolution2.default._480p:
          return _quality2.default.SDTV;
      }

      if (codecMatch !== null && codecMatch.x264) {
        return _quality2.default.SDTV;
      }

      var quality = _quality2.default.Unknown;

      // TODO: next conditions are strange, because even if the inside if is true, second value will be set... Use else?
      if (normalizedName.indexOf('848x480') !== -1) {
        if (normalizedName.indexOf('dvd') !== -1) {
          quality = _quality2.default.DVD;
        }

        quality = _quality2.default.SDTV;
      }

      if (normalizedName.indexOf('1280x720') !== -1) {
        if (normalizedName.indexOf('bluray') !== -1) {
          quality = _quality2.default.Bluray720p;
        }

        quality = _quality2.default.HDTV720p;
      }

      if (normalizedName.indexOf('1920x1080') !== -1) {
        if (normalizedName.indexOf('bluray') !== -1) {
          quality = _quality2.default.Bluray1080p;
        }

        quality = _quality2.default.HDTV1080p;
      }

      if (normalizedName.indexOf('bluray720p') !== -1) {
        quality = _quality2.default.Bluray720p;
      }

      if (normalizedName.indexOf('bluray1080p') !== -1) {
        quality = _quality2.default.Bluray1080p;
      }

      var otherSourceMatch = _xregexp2.default.exec(normalizedName, _regex2.default.otherSource);
      if (otherSourceMatch !== null) {
        if (otherSourceMatch.sdtv) {
          quality = _quality2.default.SDTV;
        }

        if (otherSourceMatch.hdtv) {
          quality = _quality2.default.HDTV720p;
        }
      }

      if (quality === _quality2.default.Unknown || quality === null) {
        var ext = _path2.default.extname(name);

        if (ext && _fileExtension2.default[ext]) {
          quality = _fileExtension2.default[ext];
        }
      }

      return quality;
    }
  }, {
    key: 'parseResolution',
    value: function parseResolution(name) {
      /*jshint curly: false */
      var match = _xregexp2.default.exec(name, _regex2.default.resolution);

      debug('Resolution Regex matches', match);

      if (match === null) return _resolution2.default.Unknown;
      if (match._480p) return _resolution2.default._480p;
      if (match._576p) return _resolution2.default._576p;
      if (match._720p) return _resolution2.default._720p;
      if (match._1080p) return _resolution2.default._1080p;
      if (match._2160p) return _resolution2.default._2160p;
    }
  }, {
    key: 'parseRevision',
    value: function parseRevision(name) {
      var revision = {
        version: 1,
        real: null
      };

      var isProper = _xregexp2.default.test(name, _regex2.default.proper);

      if (isProper) {
        revision.version = 2;
      }

      /*const versionResult = XRegExp.exec(name, Regex.version);
      if(versionResult !== null) {
        revision.version = parseInt(versionResult.version);
      }*/

      return revision;
    }
  }]);

  return TorrentNameParser;
}();

module.exports = TorrentNameParser;